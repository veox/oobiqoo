# Brainstorm on token storage layout

Dump from Majoolr chat on Discord:

-----

Are there any examples of "upgrade-friendly" contracts using Majoolr libraries?..

As in, keeping an `address` reference in storage, and a `set()` method for it, so that when a library is updated, the reference in this contract can be updated, too.

The `README`s for `BasicMathLib` and `TokenLib` show an approach of  "static linking" (for lack of a better term). The [article above](https://medium.com/rocket-pool/upgradable-solidity-contract-design-54789205276d) (from Rocket Pool) mentions how this could have been done in the Parity multisig contract - except they were using a direct `delegatecall` scheme there, so it is more trivial...

The best I was able to come up with to that effect:  a mapping of "supported signatures" (~~`bytes8`~~ `bytes4`) to "handler libraries" (`address`), with a subsequent `delegatecall` on match. Not too unlike the Parity Multisig.

Because, so far, using the approach in `TokenLib`'s `README`, I've got to wrap all ERC20 function signatures to `TokenLib` calls - much like in the `TokenContract` example. This basically bloats the contract with a static look-up table, generated by `solc` - fair enough, these are always present; it would be nice though if it wasn't static (in contract code), but dynamic (in storage)...

`^^^` Flushed thought process, sorry for that. `^^^`

**I think what I want is to rewrite the token in LLL.**

-----
-----

Contract storage is addressable by 256 bits (32 bytes).

Namespace spans:

* token balances: 20 bytes (size of `address`);
* token allowances: 40 bytes (two `address`es) - this presents a challenge; :/
* function lookup: 4 bytes (size of function signature).

-----

E.g.:

* `0x 00000000 00000000 00000000 ........ ........ ........ ........ ........` - `token-balances`;
* `0x 01...... ........ ........ ........ ........ ........ ........ ........` - `token-allowances`;
* `0x XX...... ........ ........ ........ ........ ........ ........ ........` - `UNALLOCATED`;
* `0x ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff XXXXXXXX` - `delegate-call-to`;
* `0x ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff` - `FWORD`.

(`..` denotes any value, `XX` - any value not otherwise explicitly listed.)

The libraries being delegated to need to know of this layout scheme. Therefore, reusing existing libraries is severely limited, if at all possible.

-----

On `FWORD` special case above:

* if a signature is not found in `delegate-call-to`, the call is delegated to the "default" library, the address of which is stored in the `FWORD` location;
* if the call data has `0xffffffff` up-front as a signature, then the subsequent 32 bytes are interpreted as a storage address for which the value is to be returned.

This **does not have to** be implemented in the contract!

In fact, a call with data

`0x ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff`

_will_ find a value in location `0x[ffffffff]` when processed regularly via `delegate-call-to` - which will be the "default" library's address, - and so will pass the call down to it. The library, upon seeing the `0xffffffff` signature, will know to return the value in `0x[ffffffff]` of the calling contract. Incidentally, it will be the library's own address.

**However**, it may be useful to provide this functionality in both, i.e. as described above and locally.

-----

**NOTE:** An earlier edit had the special location named `DEFAULT`, at `0x[fffffff0]`, and therefore the loop-back behaviour when calling with signature `0x00000000` (or, potentially, no data at all?); not sure yet if it's more prudent than `0x[ffffffff]` and `FWORD`.

Default action for zero-value no-data transactions is `mint()` in current prototype.

-----
-----

See [benjaminion/LLL_erc20 at github](https://github.com/benjaminion/LLL_erc20) for existing work on ERC20 token implementation in LLL.

In particular, the approach to keeping the allowances in the same contract:

``` lisp
  ;;  The following define the key data-structures:
  ;;    - balance(addr) => value
  ;;    - allowance(addr,addr) => value

  ;; Balances are stored at s[owner_addr].
  (def 'balance (address) address)

  ;; Allowances are stored at s[owner_addr + keccak256(spender_addr)]
  ;;   We use a crypto function here to avoid any situation where
  ;;   approve(me, spender) can be abused to do approve(target, me).
  (def 'allowance (owner spender)
    (seq
      (mstore mem-keccak spender)
      (add owner (keccak256 mem-keccak 0x20))))
```

**NOTE:** There is a possibility of storage location collision here. The initial assessment, submitted as [an issue](https://github.com/benjaminion/LLL_erc20/issues/1), had the probability of this happening off by 2^96.

Nevertheless, however unlikely, this can be eliminated completely by non-overlapping storage.

A systemic quirk for 1/2^X (where likely X>=64) of possible owner-spender pairs - i.e. the impossibility of formally correct behaviour for these; is pitted against an (at least) twice as higher probability to experience this by _any_ owner-spender pair, including the ones just "rescued", and a glimmer of hope for formal correctness.

This trade-off is not a simple one, but I'm leaning towards the latter, out of personal distrust of edge cases.

-----
-----

**NOTE**: current implementation of `oobiqoo` has a few non-ERC20 storage locations used: `prevMintTime`, `allowMinting`, perhaps more.

These _should_ be stored somewhere, and probably not externally.

How about `0x[0000000.]`?.. In Ethereum, these are "reserved" for pre-computes...

-----

Or, perhaps:

* `0x 00000000 00000000 00000000 00000000 00000000 00000000 00000000 ........` - `delegate-call-to`;
* `0x 00000000 00000000 00000000 00000000 00000000 00000000 XXXXXXXX ........` - `config`;
* `0x 00000000 00000000 00000000 XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX ........` - `token-balances`;
* `0x 00000000 00000000 00000000 ffffffff ffffffff ffffffff ffffffff ffffffff` - `FORBIDDEN`;
* `0x XXXXXXXX XXXXXXXX XXXXXXXX ........ ........ ........ ........ ........` - `token-allowances`;
* `0x ffffffff ffffffff ffffffff ........ ........ ........ ........ ........` - `UNALLOCATED`.

This, however, would need a lot of attention - e.g. that token transfers to `0x[00000]` don't overwrite important data.

It seems safer not to wedge one kind of data into the location of another.

-----
-----

**NOTE:** so far the storage contract itself has no code associated; its ABI definition is essentially the "default" library's ABI, extended/overriden by signatures in `delegate-call-to`.

-----

It seems that allowing some signatures to be delegated directly to a different contract than the default one introduces a security vulnerability.

The other contract - not necessarily a library even! - may manipulate the calling contract's storage in unexpected ways.

Therefore, adding signatures to `delegate-call-to` should be accompanied by a corresponding write to storage somewhere, to indicate that there _are_ overrides, - think of it as a "fuse"... Yet, in the presence of such overrides, a guarantee can not be made that they don't "reset" the fuse!

OTOH, perhaps _all_ calls should be forwarded to the "default" handler, which then _could_ decide if overrides are to be allowed.

-----
-----

Considering upgrade paths: say there's a token storage contract `oo`, and libraries `v0.1.0`, `v0.2.0`, `v1.0.0`, `v1.0.1`. Suppose `v1.0.0` has a severe bug, and _staying_ on that version between blocks is undesirable.

Now, suppose every library has exactly one `upgrade-to` target (this is an easy data structure to implement). Then, to upgrade `oo` from using `v0.2.0` to using `v1.0.1`, the process must be done in one transaction. Depending on how access control is implemented in `oo`, this may be impossible - e.g. due to rigid "ownership" constraints.

Suppose instead a library can have multiple `upgrade-to` targets (somewhat more difficult to implement). An additional complexity then is that, whether taking a "direct" path from `v0.2.0` to `v1.0.1`, or an incremental one through the `v1.0.0` intermediary, the resulting state of `oo` _must_ be the same.

Ideally, no storage changes should be done as part of the upgrade process, apart from the inevitable replacement of the library reference.

-----

Having multiple viable targets also allows "diverging implementations", e.g. due to changes being unacceptable to some users. Say they continue with a different approach in their `oo`s, dubbing it `v0.3.0`.

Those on `v1.0.1` wish to never interact with `v0.3.0`, and upgrading to `v1.0.1` from `v0.3.0` should be impossible. The latter can perhaps be achieved by having an `upgrade-from` in addition to (or instead of) an `upgrade-to`.

This _should_ also make it impossible for users of `v0.3.0` to "downgrade" to `v0.2.0` - the latter library would not accept this path. However, this _can not_ be guaranteed if `oo` is the only authority on which library it is using.

This is likely where the `registry` should come into play, in some "arbiter" form...
